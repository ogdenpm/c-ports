/****************************************************************************
 *  plm2a.c: part of the C port of Intel's ISIS-II plm80                  *
 *  The original ISIS-II application is Copyright Intel                     *
 *                                                                          *
 *  Re-engineered to C by Mark Ogden <mark.pm.ogden@btinternet.com>         *
 *                                                                          *
 *  It is released for academic interest and personal use only              *
 ****************************************************************************/
#include "os.h"
#include "plm.h"
#include <stdlib.h>

/*
    indexed by cfCode
    a bbb ccc 0
*/
byte fragControl[] = {
    0,    0,    0,    0,    0x26, 0x30, 0x30, 0x26, 0x30, 0x20, 0x30, 0x12, 0x12, 0x12, 0,    0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x60, 0,    0x26, 0x20, 0x20, 0,    0,    0,    0,    0,    0,
    0x10, 0x80, 0x80, 0x80, 0x90, 0x90, 0x40, 0xA0, 0xA0, 0xA0, 0x80, 0xB0, 0x90, 0x80, 0xB0, 0x90,
    0x80, 0xB0, 0x90, 0x80, 0xB0, 0x90, 0x80, 0xB0, 0x90, 0x20, 0x30, 0x30, 0x30, 0x10, 0x10, 0x70,
    0x70, 0x30, 0x30, 0x30, 0x30, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0x20, 0x20, 0,    0,    0x20, 0,    0,    0x2C,
    0x40, 0,    0x10, 0x10, 0x60, 0x20, 0,    0,    0xA0, 0xA0, 0xA0, 0xA0, 0x32, 0x16, 0x10, 0x20,
    0,    0x10, 0x10, 0x10, 0x10, 0x10, 0x60, 0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0x70, 0x60, 0x60, 0x70, 0x50, 0x70, 0x60, 0x60, 0xE0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0,    0,    0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80
};

byte b4128[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 9, 0xA };

byte b413B[] = { 0,    2,    4,    6,    8,    0xA,  0xC, 0x10, 0x11, 0xE,  0x12, 0,   2,    4,
                 6,    8,    0xA,  0xC,  0x10, 0x11, 0xE, 0x12, 0,    2,    4,    6,   8,    0xA,
                 0xC,  0x10, 0x11, 0xE,  0x12, 0,    2,   4,    6,    8,    0xA,  0xC, 0x10, 0x11,
                 0xE,  0x12, 0,    2,    4,    6,    8,   0xA,  0xC,  0x10, 0x11, 0xE, 0x12, 0xC,
                 0x11, 0x12, 0xC,  0x11, 0x12, 2,    6,   0,    4,    6,    8,    0xA, 0xC,  0xE,
                 0x10, 0x11, 0x12, 0xD,  0xF,  7,    9,   0xB,  1,    5,    3 };

/*
    each entry is encoded as
    (module id << 2) + relative helper id
*/
byte helperMap[][11] = {
    /* 11 byte entries */
    { 94, 95, 96, 97, 98, 99, 100, 101, 103, 104, 102 },
    { 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 81 },
    { 0, 0, 0, 0, 0, 0, 69, 70, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 71, 72, 0, 0, 0 },
    { 0, 61, 0, 0, 62, 63, 59, 60, 0, 0, 0 },
    { 0, 66, 0, 0, 67, 68, 64, 65, 0, 0, 0 },
    { 0, 86, 0, 0, 87, 88, 84, 85, 0, 0, 0 },
    { 0, 91, 0, 0, 92, 93, 89, 90, 0, 0, 0 },
    { 0, 0, 0, 0, 11, 12, 13, 14, 15, 16, 17 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
    { 0, 34, 0, 35, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 29, 0, 30, 0, 0, 0, 0, 0, 0, 0 },
    { 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28 },
    { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58 },
    { 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116 },
    { 36, 38, 37, 39, 40, 41, 0, 0, 0, 0, 0 },
    { 42, 43, 44, 45, 46, 47, 0, 0, 0, 0, 0 },
    { 0, 31, 0, 0, 32, 33, 0, 0, 0, 0, 0 },
    { 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};

byte helperGroup[] = { 8, 0x1C, 0xC, 0, 0xB, 0x11, 1, 0xA, 0xF,  0x10, 0xD,
                       9, 2,    3,   4, 5,   6,    7, 0,   0x1E, 0x12, 0xE };

byte b4273[]       = { 3, 3, 3, 3, 3, 3, 0xC, 0xD, 0xE, 0xF, 0x10, 0x11, 0, // was also b457C in
                                                                            // plm4a.c
                       0, 0, 0, 0, 0, 0, 0, 0x12, 7, 4, 4, 2, 0xA, 0x15, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0xB,
                       6, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 5, 1, 1, 1, 0x13, 0x13, 0x13, 1, 1, 1, 0x13,
                       0x13, 0x13, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0xC,
                       0xC, 0xC, 0xC, 0xC, 0xC, 0xC, 0xC, 0xD, 0xD, 0xD, 0xD, 0xD, 0xD, 0xD, 0xD, 0, 0xE,
                       0xE, 0xE, 0xE, 0xF, 0xF, 0xF, 0xF, 0, 0xF, 0xF, 0xF, 0xF, 0xE, 0xE, 0xE, 0xE, 0,
                       0x10, 0x10, 0x10, 0x10, 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 };

byte b42F9[]       = {
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0x10, 0,    0,    0,    0,    0,    0,
    0,    0,    0x10, 0,    0x20, 0,    0,    0x13, 0,    0,    0,    0,    0,    0,    0,    0,
    0x50, 0,    0,    0,    0x10, 0x10, 0x20, 0x10, 0x10, 0x10, 0,    0x50, 0x50, 0,    0x50, 0x50,
    0,    0x50, 0x50, 0,    0x50, 0x50, 0,    0x50, 0x50, 0x40, 0,    0x10, 0x10, 0x20, 0x20, 0x60,
    0x60, 0x60, 0x60, 0x60, 0x60, 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0x40, 0x40, 0,    0,    0x10, 0,    0,    0x21,
    0x10, 0,    0x10, 0x10, 0x10, 0x40, 0,    0,    0x10, 0x10, 0x10, 0x10, 0x12, 0,    0,    0x40,
    0,    0,    0,    0,    0,    0,    0x10, 0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0
};

// xxx nnnnn    nnnnn -> code sequence length
// indexed by curOp
byte codeAttrLen[] = {
    0,    0x20, 0x40, 0x60, 0x81, 0x81, 0x84, 0x83, 0x83, 1,    0x83, 0x82, 0x83, 0x81, 0x81, 0x82,
    0x83, 0x83, 1,    0x83, 0x81, 0x82, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x21, 0x22, 0x23, 0x24,
    0x82, 0x81, 0x82, 0x83, 1,    2,    2,    0x21, 0x22, 0x23, 1,    2,    1,    2,    3,    2,
    4,    5,    4,    4,    5,    4,    3,    4,    3,    0x21, 0x85, 0x83, 0x83, 0x84, 0x83, 3,
    0x23, 0x88, 0x89, 0x8D, 0x91, 1,    2,    3,    4,    5,    4,    3,    2,    5,    4,    3,
    2,    4,    5,    6,    6,    5,    4,    3,    0x62, 0x41, 1,    2,    2,    2,    1,    0x8A,
    0x82, 0x83, 1,    1,    0x84, 0x61, 0xC,  0xE,  0x41, 0x42, 0x61, 0x62, 3,    2,    1,    0x62,
    0x61, 0,    0,    0,    0,    0,    0x84, 0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x23, 0x23, 0x23, 0x23,
    6,    6,    6,    1,    1,    1,    2,    0x20, 0x60, 3,    0x20, 0x40, 0,    0,    0,    0,
    0,    0,    0x60, 0x60, 0x40, 0,    0x80, 0x84, 7,    7,    4,    5,    0,    0,    0x84, 0x84,
    0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 7,    7,    7,    7,    7,    7,    7,
    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,    5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    5,    0x43, 0x43, 0x43, 0x63, 0x63, 0x63, 0x23, 0x23, 0x23, 0x23, 0x23,
    0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 3,    3,    0x23, 0x23, 0x23, 0x23, 0x23, 0x23
};

byte b44F7[] = {
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x50, 0x5C, 0x5D, 0x5E, 5,    0x50, 0x5C, 0x5D, 0xED, 0xCD,
    0xDE, 0xDC, 0xDE, 0xDC, 0xDE, 0xDC, 0x85, 0x85, 0x85, 5,    0x15, 0x25, 0x35, 0xC5, 0xD5, 0xE5,
    5,    0x15, 0x25, 0x35, 0xC5, 0xD5, 0xE5, 0xC5, 0xD5, 0xE5, 0xFE, 0x85, 0x40, 0xB0, 0xB1, 0xB2,
    0xBC, 0xBD, 0x80, 0x81, 0x82, 0x8C, 0x8D, 0x5E, 0x15, 0x25, 0x35, 0xC5, 0xD5, 0xE5, 0xC5, 0xD5,
    0xE5, 5,    5,    0xE5, 5,    0xE5, 5,    0xE5, 5,    0xE5, 5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    5,    5,    5,    5,    0xB1, 0xE1, 0xD1, 0xB1, 0xE1, 0xD1, 0x81, 1,
    0x81, 1,    0x81, 1,    0xB1, 0xE1, 0xD1, 5,    5,    0xC5, 0xD5, 0xE5, 0x95, 0xB5, 0xA5, 5,
    0xC5, 0xD5, 0xE5, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0x95, 0xA5, 0xB5, 5,    0x15, 0x25, 0x35,
    5,    0x15, 0x25, 0x35, 0xC5, 0xD5, 0xE5, 0x65, 0x75, 0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5,
    0x65, 0x75, 0x85, 0x95, 0xA5, 0xB5, 0xBC, 0xBD, 0x9E, 0xAE, 0x8C, 0x8D, 0x6E, 0x7E, 0x6A, 0x7B,
    0x8A, 0x86, 0x87, 0x68, 0x78, 0x89, 0x8A, 0x6B, 0x7B, 0xE6, 0xE7, 0xC8, 0xD8, 0xE9, 0xEA, 0xCB,
    0xDB, 0xA6, 0xB7, 0xA8, 0xA9, 0xBA, 0xAB, 0xC5, 0xD5, 0xE5, 0xC5, 0xD5, 0xE5, 0xC5, 0xD5, 0xE5,
    0xC5, 0xD5, 0xE5, 0xC5, 0xD5, 0xE5, 0xC5, 0xD5, 0xE5, 5,    0xC5, 0xD5, 0xE5, 0xE5, 0x55, 0xED,
    0xCE, 0xDE, 0xEC, 0xA0, 0xB0, 0xBD, 0xAE, 0xA,  0xB,  0xDB, 0xEA, 0x80, 0x50, 0x10, 0x20, 0x30,
    0x9A, 0xBA, 0xCA, 8,    5,    1,    2,    3,    0xA9, 0xAB, 0xAC, 0xA0, 0xB0, 0xBD, 0xAE, 0xA,
    0xB,  0xDB, 0xEA, 0x80, 0x50, 0x10, 0x20, 0x30, 0x9A, 0xBA, 0xCA, 8,    5,    1,    2,    3,
    0xA9, 0xAB, 0xAC, 0xE0, 0xED, 0xD,  0xCD, 0xE,  0xDE, 0xD0, 0xDC, 0xE,  0xDE, 0xD0, 0xDC, 8,
    5,    1,    2,    3,    0xA9, 0xAB, 0xAC, 0xB,  0xDB, 0xA0, 0xAE, 0xA9, 0xAB, 0xAC, 0xB,  0xDB,
    0xA0, 0xAE, 0xE,  0xDE, 0xD0, 0xDC, 8,    5,    1,    2,    3,    8,    5,    1,    2,    3,
    0xA9, 0xAB, 0xAC, 0xB,  0xDB, 0xA0, 0xAE, 0xE,  0xDE, 0xD0, 0xDC, 0x9A, 0xBA, 0xCA, 0xB0, 0xBD,
    0xA,  0xEA, 0xE0, 0xED, 0xD,  0xCD, 0x80, 0x50, 0x10, 0x20, 0x30, 0x80, 0x50, 0x10, 0x20, 0x30,
    0x9A, 0xBA, 0xCA, 0xB0, 0xBD, 0xA,  0xEA, 0xE0, 0xED, 0xD,  0xCD, 8,    5,    1,    2,    3,
    0xA9, 0xAB, 0xAC, 0xB,  0xDB, 0xA0, 0xAE, 0xE,  0xDE, 0xD0, 0xDC, 0x80, 0x50, 0x10, 0x20, 0x30,
    0x9A, 0xBA, 0xCA, 0xB0, 0xBD, 0xA,  0xEA, 0xE0, 0xED, 0xD,  0xCD, 8,    5,    1,    2,    3,
    0xA9, 0xAB, 0xAC, 0xB,  0xDB, 0xA0, 0xAE, 0xE,  0xDE, 0xD0, 0xDC, 0x80, 0x50, 0x10, 0x20, 0x30,
    0x9A, 0xBA, 0xCA, 0xB0, 0xBD, 0xA,  0xEA, 0xE0, 0xED, 0xD,  0xCD, 8,    5,    1,    2,    3,
    0xA9, 0xAB, 0xAC, 0xB,  0xDB, 0xA0, 0xAE, 0xE,  0xDE, 0xD0, 0xDC, 0x80, 0x50, 0x10, 0x20, 0x30,
    0x9A, 0xBA, 0xCA, 0xB0, 0xBD, 0xA,  0xEA, 0xE0, 0xED, 0xD,  0xCD, 8,    5,    1,    2,    3,
    0xA9, 0xAB, 0xAC, 0xB,  0xDB, 0xA0, 0xAE, 0xE,  0xDE, 0xD0, 0xDC, 0x80, 0x50, 0x10, 0x20, 0x30,
    0x9A, 0xBA, 0xCA, 0xB0, 0xBD, 0xA,  0xEA, 0xE0, 0xED, 0xD,  0xCD, 0xCD, 0x35, 0xE5, 0x15, 0x25,
    0x35, 0xC5, 0xD5, 0xE5, 0xC5, 0xD5, 0xE5, 0xE5, 0x65, 0x75, 0x85, 0x95, 0xA5, 0xB5, 0x65, 0x75,
    0x85, 0x65, 0x75, 0x85
};

byte b46EB[] = {
    0x18, 0x26, 0x18, 0x18, 0x18, 0x18, 0,    0x12, 0x12, 0x12, 0x2E, 0x27, 0x27, 0x27, 0x2D, 0x2A,
    0x2D, 0x2A, 0x2B, 0x28, 0x2C, 0x29, 0,    0,    0,    0x12, 7,    5,    2,    7,    5,    2,
    0x12, 7,    5,    2,    7,    5,    2,    7,    5,    2,    0,    0,    0,    1,    1,    1,
    1,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0x12, 0x12, 2,    0x12, 2,    0x12, 2,    0x12, 2,    0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0xA,  9,    0xB,  0xA,  9,    0xB,  0x17, 0x17,
    0x17, 0x17, 0x17, 0x17, 0x23, 0x22, 0x24, 0x12, 0x12, 0x1E, 0x1E, 0x1D, 0x1F, 0x20, 0x1C, 0x12,
    0x12, 0x12, 0x12, 0x12, 0x12, 2,    0x12, 0x12, 0x12, 0xD,  0x10, 0x13, 0x12, 7,    5,    2,
    0x12, 7,    5,    2,    7,    5,    2,    7,    5,    2,    7,    5,    2,    7,    5,    2,
    7,    5,    2,    7,    5,    2,    2,    2,    2,    2,    2,    2,    2,    2,    0x1C, 0x20,
    0x1C, 2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
    2,    0x1C, 0x20, 0x1C, 0x1C, 0x20, 0x1C, 7,    5,    2,    7,    5,    2,    7,    5,    2,
    7,    5,    2,    7,    5,    2,    7,    5,    2,    0,    0,    0,    0,    0,    0,    2,
    2,    2,    2,    0x1C, 0x20, 0x20, 0x1C, 0x1C, 0x20, 0x20, 0x1C, 0x12, 0x12, 0x12, 0x12, 0x12,
    0x1A, 0x21, 0x1C, 0x12, 0x12, 0x12, 0x12, 0x12, 0x1A, 0x21, 0x1C, 0x1C, 0x20, 0x20, 0x1C, 0x1C,
    0x20, 0x20, 0x1C, 0x12, 0x12, 0x12, 0x12, 0x12, 0x1A, 0x21, 0x1C, 0x12, 0x12, 0x12, 0x12, 0x12,
    0x1A, 0x21, 0x1C, 0x1B, 0x1D, 0x19, 0x1D, 0x1B, 0x1D, 0x19, 0x1D, 0x1B, 0x1D, 0x19, 0x1D, 0x12,
    0x12, 0x12, 0x12, 0x12, 0x1A, 0x21, 0x1C, 0x20, 0x20, 0x1C, 0x1C, 0x1A, 0x21, 0x1C, 0x20, 0x20,
    0x1C, 0x1C, 0x1B, 0x1D, 0x19, 0x1D, 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0x1A, 0x21, 0x1C, 0x20, 0x20, 0x1C, 0x1C, 0x1B, 0x1D, 0x19, 0x1D, 0x1A, 0x21, 0x1C, 0x20, 0x20,
    0x1C, 0x1C, 0x1B, 0x1D, 0x19, 0x1D, 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0x1A, 0x21, 0x1C, 0x20, 0x20, 0x1C, 0x1C, 0x1B, 0x1D, 0x19, 0x1D, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x12, 0x12, 0x12, 0x12, 0x12,
    0xE,  0x16, 0x11, 0x15, 0x15, 0x11, 0x11, 0xF,  0x14, 0xC,  0x14, 0x25, 0x26, 0x26, 0,    0,
    0,    0,    0,    0,    7,    5,    2,    2,    7,    5,    2,    7,    5,    2,    7,    5,
    2,    7,    5,    2
};

word w48DF[] = { 0,      1,      0x1000, 0x1000, 0x2000, 0x2000, 0x2000, 0x4000, 0x4000, 0x5000,
                 0x6008, 0x6000, 0x5080, 0x8040, 0xD088, 0x3010, 0x8008, 0x9008, 0x8000, 0x8001,
                 0x9000, 0xA008, 0xD088, 0xC000, 0xF000, 0x5080, 0xD088, 0x3010, 0x9008, 0x9000,
                 0xA000, 0xB008, 0xA008, 0xD088, 0xD000, 0xE008, 0xE000, 0xE000, 0xF000, 0xF000,
                 0xB000, 0xB000, 0xB000, 0xE000, 0xE000, 0xE000, 0xC000 };

word w493D[] = { 0x123,  0x123,  0x124,  0x126,  0x134,  0x143,  0x163,  0x423,  0x623,  0x624,
                 0x634,  0x634,  0x4026, 0x4123, 0x4126, 0x4106, 0x4123, 0x4126, 0x4123, 0x4123,
                 0x4126, 0x4136, 0x4326, 0x4623, 0x4666, 0x6024, 0x6124, 0x6104, 0x6124, 0x6124,
                 0x6134, 0x6114, 0x6134, 0x6324, 0x6624, 0x6634, 0x6634, 0x6663, 0x6664, 0x6666,
                 0x5146, 0x5164, 0x5154, 0x5346, 0x5364, 0x5354, 0x5623 };

byte b499B[] = { 0x10, 0x10, 0x20, 0x20, 0x10, 0x10, 2,    2, 5,    5,    5,    5,    1,    3,
                 1,    6,    3,    3,    3,    0x1C, 0x10, 4, 2,    2,    0x20, 0x20, 0x20, 0xE,
                 7,    4,    8,    7,    7,    6,    6,    6, 0x20, 0x10, 0x10, 0x10, 0x20, 0x20,
                 0x10, 0x10, 3,    7,    7,    3,    7,    7, 3,    1,    1,    1,    1,    1,
                 1,    1,    6,    3,    1,    0xE,  4,    2, 6,    0xD,  1,    1,    1,    1,
                 1,    4,    1,    1,    3,    3,    3,    1, 1,    1,    1,    1,    1,    1,
                 1,    1,    1,    1,    1,    1,    1,    1, 1,    4,    1,    1,    1,    1,
                 1,    1,    1,    1,    4,    1,    1,    1, 1,    1,    1,    1,    1,    1,
                 2,    2,    2,    2,    1,    1,    1,    1, 1,    1,    1,    1,    1,    1,
                 1,    3,    3,    3,    0x1C, 2,    1,    1 };

byte b4A21[] = {
    0x3F, 0x40, 0x44, 0x43, 0x41, 0x42, 0x60, 0x6C, 0x6C, 0x6C, 0x61, 0x64, 0x5F, 0x5F, 0xEB, 0xEF,
    0xEB, 0xEF, 0xEB, 0xEF, 0xEB, 0xEF, 0x21, 0x22, 0x23, 0x24, 0x24, 0x24, 0x24, 0x27, 0x27, 0x27,
    0x25, 0x25, 0x25, 0x25, 0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x3B, 0x26, 0x3C, 0x3D, 0x3D, 0x3D,
    0x3E, 0x3E, 0x14, 0x14, 0x14, 0x14, 0x14, 0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
    0x17, 0x4C, 0x45, 0x1C, 0x46, 0x1D, 0x47, 0x1E, 0x48, 0x1F, 0x49, 0x4A, 0x4B, 0x4D, 0x4E, 0x4F,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0xFE, 0xFB, 0xFA, 0xFE, 0xFB, 0xFA, 0xF7, 0xF8,
    0xF7, 0xF8, 0xF7, 0xF8, 0xFE, 0xFB, 0xFA, 0x5E, 0x5A, 0xF9, 0xFA, 0xFB, 0xFC, 0xFE, 0xFD, 0x5B,
    0x62, 0x62, 0x62, 9,    9,    0x12, 0x63, 0x63, 0x63, 0x5C, 0x5C, 0x5D, 0,    0,    0,    0,
    0,    0,    0,    0,    1,    1,    1,    2,    2,    2,    3,    3,    3,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    0x58, 0x58, 0x6F, 0x6F, 0x59, 0x59, 0x59, 0x59, 0xE5, 0xE6,
    0xE7, 0x59, 0x59, 0x59, 0x59, 0x65, 0x65, 0x65, 0x65, 0x59, 0x59, 0x59, 0x59, 0x65, 0x65, 0x65,
    0x65, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 2,    2,    2,    0x68, 0x68, 0x68, 0x69, 0x69, 0x69,
    3,    3,    3,    0x6A, 0x6A, 0x6A, 0x6B, 0x6B, 0x6B, 0x1B, 0x20, 0x20, 0x20, 0x1B, 0x1B, 0x39,
    0x39, 0x39, 0x39, 0xF3, 0xF4, 0xF5, 0xF6, 0xF3, 0xF4, 0xF5, 0xF6, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C,
    0xF0, 0xF1, 0xF2, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF3,
    0xF4, 0xF5, 0xF6, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C, 0xF0, 0xF1, 0xF2, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C,
    0xF0, 0xF1, 0xF2, 0xED, 0xEB, 0xEE, 0xEF, 0xED, 0xEB, 0xEE, 0xEF, 0xED, 0xEB, 0xEE, 0xEF, 0x2A,
    0x2B, 0x2C, 0x2C, 0x2C, 0xF0, 0xF1, 0xF2, 0xF4, 0xF5, 0xF3, 0xF6, 0xF0, 0xF1, 0xF2, 0xF4, 0xF5,
    0xF3, 0xF6, 0xED, 0xEB, 0xEE, 0xEF, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C,
    0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
    0xB7, 0xB8, 0xAE, 0xAF, 0xB0, 0xB1, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C, 0x2A, 0x2B, 0x2C, 0x2C, 0x2C,
    0xF0, 0xF1, 0xF2, 0xF4, 0xF5, 0xF3, 0xF6, 0xED, 0xEB, 0xEE, 0xEF, 0x2D, 0x2E, 0x2F, 0x2F, 0x2F,
    0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xCF, 0xD0, 0xD1, 0xD2, 0x2D, 0x2E, 0x2F, 0x2F, 0x2F,
    0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xCF, 0xD0, 0xD1, 0xD2, 0x36, 0x37, 0x38, 0x38, 0x38,
    0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xDA, 0xDB, 0xDC, 0xDD, 0x36, 0x37, 0x38, 0x38, 0x38,
    0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xDA, 0xDB, 0xDC, 0xDD, 0x30, 0x31, 0x32, 0x32, 0x32,
    0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xB9, 0xBA, 0xBB, 0xBC, 0x30, 0x31, 0x32, 0x32, 0x32,
    0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xB9, 0xBA, 0xBB, 0xBC, 0x33, 0x34, 0x35, 0x35, 0x35,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xC4, 0xC5, 0xC6, 0xC7, 0x33, 0x34, 0x35, 0x35, 0x35,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xC4, 0xC5, 0xC6, 0xC7, 0x66, 0,    1,    0x17, 0x17,
    0x17, 0x17, 0x17, 0x17, 2,    2,    2,    0x70, 2,    2,    2,    3,    3,    3,    2,    2,
    2,    3,    3,    3
};

byte b4C15[] = { 0x21, 0x42, 0x42, 0x43, 0x41, 0x24, 0x34, 0x43, 0x42, 0x42, 0x42, 0x43,
                 0x45, 0x45, 0x52, 0x53, 0x50, 0x50, 0,    0,    0x60, 0x10, 0x70, 0x70 };

byte b4C2D[] = { 0x79, 1,    0x61, 0x61, 0x61, 0x61, 0x89, 0x88, 0x89, 1,    0x89, 0x89,
                 0x49, 0x89, 0x89, 0x89, 0x69, 0x89, 0x8F, 0x6F, 0x80, 0x60, 0x80, 0x80 };

byte b4C45[] = { 0x63, 0,    0x37, 0x46, 4,    5,    6,   0x3B, 0x3C, 3,    0x3A, 3,    4,    4,
                 6,    0x3A, 0x3B, 0x3B, 5,    6,    3,   4,    5,    4,    5,    6,    5,    5,
                 7,    7,    8,    8,    9,    9,    0xB, 0xB,  0xC,  0x3B, 0x3C, 0x3C, 0x3C, 0x3D,
                 0x3E, 0x3E, 0x3F, 0x3F, 0x40, 0x40, 3,   2,    2,    0x39, 1,    2,    4,    4,
                 0x38, 0x39, 1,    0x38, 3,    4,    4,   5,    7,    8,    0x3B, 0x3C, 3,    3,
                 0x3A, 1,    0x38, 3,    5,    6,    7,   9,    0xA,  0x3C, 0x3D, 0x3E, 2,    0x39,
                 1,    2,    3,    4,    0x38, 0x39, 2,   2,    4,    4,    5,    0x39, 0x39, 1,
                 2,    4,    2,    4,    5,    6,    8,   9,    0x39, 0x3B, 0x3C, 0x3D, 0x38 };

byte b4CB4[] = { 0x63, 0,    1,    0x32, 1,    2,    2,    1,    2,    1,    1,    1,    0xB,  0xD,
                 0xD,  1,    0xB,  0xD,  1,    0xB,  1,    0xB,  0xD,  1,    0xB,  0xD,  0x11, 0x13,
                 0x11, 0x13, 0x11, 0x1B, 0x19, 0x1B, 0x19, 0x1B, 0x19, 1,    0xB,  0x11, 0x13, 0xD,
                 0x11, 0x13, 0x11, 0x1B, 0x19, 0x1B, 1,    2,    1,    1,    1,    2,    1,    2,
                 1,    2,    0x2F, 0x2F, 0x2F, 0x2D, 0x2F, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2F,
                 0x2D, 3,    3,    3,    0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 3,    3,
                 1,    1,    1,    1,    1,    1,    0x1D, 0x1F, 0x1D, 0x1F, 0x1D, 0x1D, 0x1F, 3,
                 3,    3,    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 3 };

byte b4D23[][16] = {
    { 1, 0x47, 0x47, 0x47, 0, 0, 0, 0, 0, 0, 0, 0, 0x49, 0x49, 0x49, 0 },
    { 0x47, 1, 0x47, 0x47, 0, 0, 0, 0, 0, 0, 0, 0, 0x31, 0x49, 0x49, 0 },
    { 0x47, 0x47, 1, 0x61, 0, 0, 0, 0, 0, 0, 0, 0, 0x49, 0x31, 0x63, 0 },
    { 0x47, 0x47, 0x61, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x49, 0x63, 0x31, 0 },
    { 9, 0xD, 0xC, 0xB, 1, 0, 0x30, 0x30, 0x30, 0, 0, 0, 0xE, 0x13, 0x12, 0 },
    { 0x32, 0x32, 0x32, 0x32, 0, 1, 0, 0, 0, 0, 0, 0, 0x30, 0x30, 0x30, 0 },
    { 0x34, 0x35, 0x35, 0x35, 0, 0, 1, 0x52, 0x52, 0, 0, 0, 0x36, 0x37, 0x37, 0 },
    { 0x34, 0x64, 0x64, 0x64, 0, 0, 0x52, 1, 0x61, 0, 0, 0, 0x65, 0x65, 0x65, 0 },
    { 0x3A, 0x3A, 0x3A, 0x3A, 0, 0, 0x52, 0x61, 1, 0, 0, 0, 0x3C, 0x3C, 0x3C, 0 },
    { 0x38, 0x39, 0x39, 0x39, 0, 0, 2, 0x53, 0x53, 1, 0x52, 0x52, 0x4A, 0x4A, 0x4B, 0 },
    { 0x38, 0x6A, 0x6A, 0x6A, 0, 0, 0x53, 2, 0x6E, 0x52, 1, 0x61, 0x65, 0x65, 0x66, 0 },
    { 0x3B, 0x3B, 0x3B, 0x3B, 0, 0, 0x53, 0x6E, 2, 0x52, 0x61, 1, 0x45, 0x45, 0x3E, 0 },
    { 0x48, 2, 0x48, 0x48, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x52, 0x52, 0 },
    { 0x48, 0x48, 2, 0x6E, 0, 0, 0, 0, 0, 0, 0, 0, 0x52, 1, 0x61, 0 },
    { 0x48, 0x48, 0x6E, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0x52, 0x61, 1, 0 },
    { 0xA, 0x11, 0x10, 0xF, 0, 0, 0, 0, 0, 0x30, 0x30, 0x30, 0x16, 0x15, 0x14, 1 },
    { 0x33, 0x33, 0x33, 0x33, 0, 0, 0, 0, 0, 0, 0, 0, 0x30, 0x30, 0x30, 0 },
    { 0, 0, 0, 0, 0, 0, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0, 0, 0, 0 },
    { 0x4B, 0x4C, 0x4C, 0x4C, 0, 0, 0x4A, 0x4A, 0x4B, 0, 0, 0, 0x4D, 0x4D, 0x4D, 0 },
    { 0x66, 0x67, 0x67, 0x67, 0, 0, 0x65, 0x65, 0x66, 0, 0, 0, 0x68, 0x68, 0x68, 0 },
    { 0x3D, 0x3F, 0x3F, 0x3F, 0, 0, 0x44, 0x44, 0x3D, 0, 0, 0, 0x40, 0x40, 0x40, 0 },
    { 0x50, 0x51, 0x51, 0x51, 0, 0, 0x4F, 0x4F, 0x50, 0x4A, 0x4A, 0x4B, 0x4D, 0x4D, 0x4E, 0 },
    { 0x6C, 0x6D, 0x6D, 0x6D, 0, 0, 0x6B, 0x6B, 0x6C, 0x65, 0x65, 0x66, 0x68, 0x68, 0x69, 0 },
    { 0x42, 0x43, 0x43, 0x43, 0, 0, 0x46, 0x46, 0x42, 0x44, 0x44, 0x3D, 0x40, 0x40, 0x41, 0 },
    { 0x47, 1, 0x47, 0x47, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x52, 0x52, 0 },
    { 0x47, 0x47, 1, 0x61, 0, 0, 0, 0, 0, 0, 0, 0, 0x52, 1, 0x61, 0 },
    { 0x47, 0x47, 0x61, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x52, 0x61, 1, 0 },
    { 8, 8, 8, 7, 0, 3, 0, 0, 0, 0, 0, 0, 6, 5, 4, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0x19, 0x18, 0x17, 0x19, 0x18, 0x17, 0, 0, 0, 0 },
    { 0x2D, 0x2F, 0x2E, 0x2E, 0, 0, 0x2B, 0x2A, 0x2C, 0x1D, 0x1C, 0x1E, 0x23, 0x22, 0x24, 0 },
    { 0x59, 0x60, 0x5F, 0x5F, 0, 0, 0x58, 0x58, 0x58, 0x54, 0x54, 0x54, 0x5D, 0x5C, 0x5E, 0 },
    { 0x28, 0x28, 0x27, 0x27, 0, 0, 0x29, 0x26, 0x25, 0x19, 0x18, 0x17, 0x1D, 0x1C, 0x1E, 0 },
    { 0x59, 0x58, 0x58, 0x58, 0, 0, 0, 0, 0, 0, 0, 0, 0x54, 0x54, 0x54, 0 },
    { 0x55, 0x54, 0x54, 0x54, 0, 0, 0, 0, 0, 0, 0, 0, 0x54, 0x54, 0x54, 0 },
    { 0x1F, 0x21, 0x20, 0x20, 0, 0, 0x1D, 0x1C, 0x1E, 0, 0, 0, 0x23, 0x22, 0x22, 0 },
    { 0x55, 0x5B, 0x5A, 0x5A, 0, 0, 0x54, 0x54, 0x54, 0, 0, 0, 0x5D, 0x5C, 0x5C, 0 },
    { 0x1B, 0x1B, 0x1A, 0x1A, 0, 0, 0x19, 0x18, 0x17, 0, 0, 0, 0x1D, 0x1C, 0x1C, 0 },
    { 0x55, 0x54, 0x54, 0x54, 0, 0, 0, 0, 0, 0, 0, 0, 0x56, 0x56, 0x56, 0 },
    { 0x54, 0x55, 0x55, 0x55, 0, 0, 0, 0, 0, 0, 0, 0, 0x57, 0x57, 0x57, 0 }
};

byte b4FA3[] = { 0x17, 0x16, 0x16, 0x16, 0,    0,    0,    0,    0,    1,    1,    2,    2,    2,
                 2,    2,    2,    2,    3,    3,    4,    4,    4,    5,    5,    5,    5,    5,
                 5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
                 5,    5,    5,    5,    5,    5,    6,    7,    8,    8,    9,    9,    9,    9,
                 9,    9,    0xA,  0xA,  0xB,  0xC,  0xC,  0xC,  0xC,  0xC,  0xC,  0xC,  0xD,  0xD,
                 0xD,  0xE,  0xE,  0xF,  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11,
                 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x14,
                 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14 };

byte b5012[] = { 6,    8,    0xA, 0x3A, 0xA, 6,   7, 0xF, 0x6D, 9, 0x12, 0x11,
                 0x10, 0x10, 0xD, 0xC,  0xB, 0xB, 4, 4,   0xE,  5, 0,    0 };

word w502A[] = { 0, 1, 2, 3, 4, 8, 9, 0xA, 0x10, 0xFD, 0xFE, 0xFF, 0xFFFD, 0xFFFE, 0xFFFF };

byte b5048[] = { 0,    0x2A, 0,    0x2A, 0,    0x32, 0,    0x32, 0,   0x2A, 0x2A, 0,    0x2A,
                 0,    0x5A, 2,    0xA,  0,    2,    0,    9,    9,   0x11, 0x11, 0x19, 0x71,
                 0x59, 0x69, 0x51, 0x61, 1,    1,    1,    0,    1,   1,    0,    0xA,  0xA,
                 0x12, 0x12, 0x1A, 0x72, 0x5A, 0x6A, 0x52, 0x62, 2,   2,    2,    0,    0,
                 0x11, 0x21, 0x29, 0x39, 0x41, 9,    9,    0,    9,   9,    0,    8,    0,
                 0x59, 0x59, 0x71, 0x71, 0,    0,    0,    0,    1,   1,    1,    0x5B, 0x73,
                 0,    1,    1,    1,    0x59, 0x71, 0,    2,    0xA, 0x12, 2,    0xA,  0x12,
                 0,    1,    0,    1,    0,    1,    0,    1,    1,   0 };


byte stepTable[] = {
         // 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
 /* 00 */   0xFF, 0x22, 0xFF, 0x22, 0xFF, 0x22, 0xFF, 0x22, 0xFF, 0x22, 0x62, 0xFF, 0x22, 0xFF, 4,    4,
 /* 10 */   4,    0xFF, 0x50, 0xFF, 0x64, 0x85, 0x64, 0x85, 0x64, 0x64, 0xA5, 0x64, 0xA5, 0x64, 0x64, 5,
 /* 20 */   4,    0xFF, 0x64, 5,    0xFF, 0x64, 0x85, 0x64, 0x85, 0x64, 0x64, 0xA5, 0x64, 0xA5, 0x64, 0x64,
 /* 30 */   5,    4,    0xFF, 4,    4,    4,    4,    4,    4,    0x64, 4,    0xFF, 0x64, 4,    0xFF, 4,
 /* 40 */   0xFF, 0x25, 0x24, 0x64, 4,    4,    0xFF, 4,    0xFF, 0x64, 5,    4,    0x24, 4,    0xFF, 0x64,
 /* 50 */   5,    4,    0x25, 0x64, 0xFF, 0x14, 0x14, 0x14, 4,    4,    4,    0xFF, 4,    0xFF, 4,    0xFF,
 /* 50 */   4,    0xFF, 0x14, 4,    0xFF
};


// indexed by arith op
// DOUBLE, PLUSSIGN, MINUSSIGN, STAR, SLASH, MOD, AND, OR, XOR
// BASED, BYTEINDEX, WORDINDEX, MEMBER, UNARYMINUS, NOT, LOW, HIGH, ADDRESSOF
// xx yyy zzz
// zzz result attributes
byte b5112[] = { 0x5A, 0x61, 0x69, 0x92, 0x92, 0x92, 0x91, 0x91, 0x91,
                 0x5D, 0xD3, 0xD3, 0xDC, 0x9B, 0x9B, 0x98, 0x98, 0x1A };

/* clang-format off */
// note  INCLUDE (162) item changed to have only 1 word
// indexed by T2 opcode
// xxxxxxnn
// nn -> length of t2 item in words
// other bits as follows
// 80: SETSTMTNO PROCEDURE LOCALLABEL CASELABEL LABELDEF INPUT GOTO JMP JNC JNZ SIGN ZERO PARITY CARRY DISABLE ENABLE
//     HALT STMTCNT LINEINFO MODULE SYNTAXERROR TOKENERROR EOF LIST NOLIST CODE NOCODE EJECT INCLUDE ERROR STACKPTR
//     SEMICOLON OPTBACKREF CASE ENDCASE ENDPROC BEGCALL
// 40: IDENTIFIER NUMBER BIGNUMBER 175 STACKPTR SEMICOLON OPTBACKREF CASE ENDCASE ENDPROC LENGTH LAST SIZE BEGCALL
// 20: STMTCNT LINEINFO MODULE SYNTAXERROR TOKENERROR EOF LIST NOLIST CODE NOCODE EJECT INCLUDE ERROR
// 10: PROCEDURE LOCALLABEL CASELABEL LABELDEF HALT EOF ENDPROC
// 08: JMPFALSE RETURNBYTE RETURNWORD RETURN BEGMOVE CALL CALLVAR PROCEDURE GOTO JMP JNC JNZ ENDPROC
// 04: JMPFALSE CASEBLOCK
// 
// 
              // 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
byte nodeControlMap[] = {
                 2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    0xE,  1,    1,    1,    // 00
                 1,    1,    1,    2,    2,    2,    2,    2,    2,    2,    2,    2,    3,    3,    2,    1,    // 10
                 1,    1,    1,    1,    2,    2,    2,    2,    2,    2,    2,    2,    0,    0,    0,    0,    // 20
                 0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,    2,    2,    6,    // 30
                 1,    0,    0,    0,    0,    3,    0,    9,    9,    8,    1,    1,    1,    0,    0,    0,    // 40
                 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // 50
                 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // 60
                 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    // 70
                 1,    1,    2,    9,    0xB,  0xB,  0x81, 0x99, 0x91, 0x91, 0x91, 0x81, 0x89, 0x89, 0x89, 0x8A, // 80
                 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x90, 0xA1, 0xA3, 0xA0, 0xA1, 0xA2, 0xB0, 0xA0, 0xA0, 0xA0, // 90
                 0xA0, 0xA0, 0xA1, 0xA3, 0,    0,    0,    0,    0,    0,    0,    0,    0x41, 0x41, 0x41, 0x40, // a0
                 0,    0,    0,    0,    0,    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xD8, 0x41, 0x41, 0x41, 0xC0 };     // b0



                 // 0     1     2     3     4     5     6     7     8     9 
byte step2Map[] = { 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,      // LT  LE  NE  EQ GE GT ROL ROR SCL SCR
                    0,    0,    0,    0,    0,    0,    0,    0,    0x12, 0x14,   // SHL SHR JMPFALSE ..... DOUBLE PLUSSIGN
                    0x22, 0x33, 0x47, 0x47, 0x41, 0x49, 0x4F, 0,    0x5C, 0x5E,   // MINUSSIGN STAR SLASH MOD AND OR XOR BASED BYTEINDEX WORDINDEX
                    0x60 };                                                       // MEMBER

byte step1Map[] = { 0,    0,    0,    0,    0,    0,    1,    3,    5,    7,
                    9,    0xC,  0xE,  0,    0,    0,    0,    0,    0,    0x14,
                    0x25, 0x33, 0x3C, 0x3F, 0x41, 0x49, 0x4F, 0x55, 0,    0,
                    0x62 };

byte b5221[] = { 0,    0x4D, 0,    0x55, 0,    0x5D, 0,    0x66, 0,    0x6F, 0x6F, 0,    0x77,
                 0,    0xB6, 0x8D, 0xB6, 0,    0x41, 0,    0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x30,
                 0x30, 0x31, 0x31, 0x32, 0x41, 0x41, 0x12, 0,    0x1F, 0x1F, 0,    0x30, 0x30,
                 0x31, 0x31, 0x32, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x41, 0x41, 0x41, 0,    0xAD,
                 0x42, 0x43, 0x44, 0x2C, 0x46, 0x41, 0x12, 0,    0x41, 0x12, 0,    0xAD, 0,
                 0x41, 0x12, 0x41, 0x12, 0xAD, 0,    0xAD, 0,    0x41, 0x41, 0x12, 0xAD, 0xAD,
                 0,    0x41, 0x41, 0x12, 0x20, 0x20, 0,    0x4A, 0x4B, 0x4C, 0x7F, 0x80, 0x81,
                 0,    0xD,  0,    0xE,  0,    0xF,  0,    0x10, 0x11, 0 };



byte b528D[] = { 0, 0, 0, 0, 0, 0, 2, 2,   2, 3, 3, 3, 1, 1, 1, 1, 1, 8, 4, 4,
                 4, 5, 5, 5, 6, 6, 6, 0xA, 9, 8, 3, 3, 1, 1, 6, 2, 2, 0, 0, 0xB };

byte b52B5[] = { 0, 1, 2, 3, 4, 8, 1, 2, 3, 1,   2,   3, 1,   2, 3, 4,   8, 4,   1, 2,
                 3, 1, 2, 3, 1, 2, 3, 8, 8, 0xA, 0xA, 9, 0xA, 9, 9, 0xA, 9, 0xA, 9, 9 };

byte b52DD[][11] = { { 0, 1, 2, 3, 4, 0, 0, 0, 5, 0x26, 0x25 },
                     { 0, 0xC, 0xD, 0xE, 0xF, 0, 0, 0, 0x10, 0x21, 0x20 },
                     { 0, 6, 7, 8, 0, 0, 0, 0, 0, 0x24, 0x23 },
                     { 0, 9, 0xA, 0xB, 0, 0, 0, 0, 0, 0x1F, 0x1E },
                     { 0, 0x12, 0x13, 0x14, 0, 0, 0, 0, 0, 0, 0 },
                     { 0, 0x15, 0x16, 0x17, 0, 0, 0, 0, 0, 0, 0 },
                     { 0, 0x18, 0x19, 0x1A, 0, 0, 0, 0, 0, 0x22, 0 },
                     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                     { 0, 0, 0, 0, 0x11, 0, 0, 0, 0, 0, 0x1D },
                     { 0, 0, 0, 0, 0, 0, 0, 0, 0x1C, 0, 0 },
                     { 0, 0, 0, 0, 0, 0, 0, 0, 0x1B, 0, 0 },
                     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x27, 0 } };

// clang-format on

void WrFragData() {
    if (!(PRINT || OBJECT)) {
        if (fragment[0] == T2_SYNTAXERROR || fragment[0] == T2_TOKENERROR ||
            fragment[0] == T2_ERROR)
            programErrCnt++;
        return;
    }
    vfWbuf(&utf1, fragment, fragLen);
}

void PutTx1Byte(byte val) {
    fragment[fragLen++] = val;
}

void PutTx1Word(word val) {
    PutTx1Byte(Low(val));
    PutTx1Byte(High(val));
}

static byte EncodeFragPartArg(byte iArg, byte start) {
    byte argCode = (byte)iCodeArgs[iArg++];

    if (iCodeArgs[0] <= 12) {
        if (fragLen == start)
            PutTx1Byte(argCode);
        else
            fragment[start] = (fragment[start] << 4) | argCode;   // merge the icode in high/low
    }

    if (argCode > 7) {
        if (argCode == 8 || argCode == 13 || argCode == 10)
            PutTx1Byte((byte)iCodeArgs[iArg++]);
        else
            PutTx1Word(iCodeArgs[iArg++]);

        if (argCode >= 10 && argCode <= 12)
            PutTx1Word(iCodeArgs[iArg++]);
        if (argCode == 12)
            PutTx1Word(iCodeArgs[iArg++]);
    }
    return iArg;
} /* Sub_545D() */

static void EncodeFragArgs(byte frag) {
    byte iArg = 0;
    byte start = fragLen;
    if (fragControl[frag] & (7 << 4)) {
        iArg = EncodeFragPartArg(iArg, start);
        if (iCodeArgs[iArg] != 0 || iCodeArgs[0] <= 12)
            EncodeFragPartArg(iArg, start);
    }
} /* Sub_5410() */

void EncodeFragData(byte frag) {
    /* EncodeFragData() */
    fragLen = 0;
    PutTx1Byte(frag);
    if (fragControl[frag] & 0x80)
        PutTx1Byte(curNodeType);
    EncodeFragArgs(frag);
    memset(iCodeArgs, 0, sizeof(iCodeArgs));
    WrFragData();
}

void EmitTopItem() {
    fragLen = 0;
    if (!PRINT)
        if (tx2[tx2qp].nodeType == T2_LINEINFO || tx2[tx2qp].nodeType == T2_INCLUDE)
            return;
    PutTx1Byte(tx2[tx2qp].nodeType);
    if (fragControl[tx2[tx2qp].nodeType] & 0x80) {
        PutTx1Byte((byte)tx2[tx2qp].right);
        PutTx1Word(tx2[tx2qp].left);
    } else
        switch (nodeControlMap[tx2[tx2qp].nodeType] & 3) {
        case 0:
            break;
        case 1:
            PutTx1Word(tx2[tx2qp].left);
            break;
        case 2:
            PutTx1Word(tx2[tx2qp].left);
            PutTx1Word(tx2[tx2qp].right);
            break;
        case 3:
            PutTx1Word(tx2[tx2qp].left);
            PutTx1Word(tx2[tx2qp].right);
            PutTx1Word(tx2[tx2qp].extra);
            break;
        }
    WrFragData();
}

void Tx2SyntaxError(byte arg1b) {
    tx2[tx2qp].nodeType = T2_SYNTAXERROR;
    tx2[tx2qp].left     = arg1b;
}

byte Sub_5679(byte lrIdx) {
    return lrIdx == Left ? b44F7[wC1D6] >> 4 : b44F7[wC1D6] & 0xf;
}

void MoveTx2(byte src, byte dst) {
    tx2[dst] = tx2[src];
}

byte IndirectAddr(byte attr) {
    return attr == STRUCT_A ? 2 : attr + 2;
}

void Sub_5795(word arg1w) {
    word offset, q;

    offset = arg1w + wC1C3 * 2;
    q = ((offset + 1) >> 1) + 2; // convert to words
    if (curNodeType == T2_RETURNWORD)
        q -= 2;
    if (q > 7) {
        if (exprLoc[0] == 3)
            EncodeFragData(CF_XCHG);
        iCodeArgs[0] = IR_SR;
        iCodeArgs[1] = offset;
        EncodeFragData(CF_SA2HL);
        EncodeFragData(CF_SPHL);
        if (exprLoc[0] == 3) {
            EncodeFragData(CF_XCHG);
            codeSize += 7;
        } else
            codeSize += 5;
    } else {
        if (offset & 1) {
            EncodeFragData(CF_INXSP);
            codeSize++;
        }
        while (offset > 1) {
            if (exprLoc[0] == 3)
                iCodeArgs[0] = IR_D; /*  pop d */
            else
                iCodeArgs[0] = IR_H; /*  pop h */
            iCodeArgs[1] = LOC_REG;
            EncodeFragData(CF_POP);
            codeSize++;
            offset -= 2;
        }
    }
    if (arg1w > 0xff00)
        wC1C3 = (word)(-arg1w) >> 1;
    else
        wC1C3 = 0;
}

bool EnterBlk() {
    if (activeGrpCnt < 20) {
        activeGrpCnt++;
        return true;
    }
    if (blkOverCnt == 0) {
        Tx2SyntaxError(ERR204); /*  LIMIT EXCEEDED: NUMBER OF ACTIVE */
                                /*  PROCEDURES and do CASE GROUPS */
        EmitTopItem();
    }
    blkOverCnt++;
    return false;
}

bool ExitBlk() {
    if (blkOverCnt > 0) {
        blkOverCnt--;
        return false;
    } else if (activeGrpCnt > 0) {
        activeGrpCnt--;
        return true;
    } else {
        Tx2SyntaxError(ERR205); /*  ILLEGAL NESTING OF BLOCKS, ENDS not BALANCED */
        EmitTopItem();
        return false;
    }
}


void Sub_58F5(word err) {
    fatalCode = err;
    fragment[0]    = T2_SYNTAXERROR;
    fragment[1]    = (byte)fatalCode;
    fragment[2]    = 0;
    fragLen        = 3;
    WrFragData();

    while (activeGrpCnt > 0) {
        if (ExitBlk()) {
            if (blkId > activeGrpCnt) {
                info             = blk[blkId].info;
                info->codeSize   = codeSize;
                info->stackUsage = stackUsage;
                blkId            = blk[blkId].next;
                codeSize         = blk[blkId].codeSize;
                stackUsage       = blk[blkId].stackSize;
            }
        }
    }
    longjmp(exception, -1);
}

void Sub_597E() {
    byte i, j, k, n;
    bool m;

    bC0B2 = 0;
    bC0B1 = 0;
    for (i = 0; i <= 3; i++) {
        boC069[i] = false;
        boC072[i] = false;
        boC07B[i] = false;
        k         = bC04E[i];
        n         = nodeControlMap[tx2[k].nodeType] & 0xc0;
        if (k != 0) {
            boC060[i] = true;
            if (exprLoc[0] == i || exprLoc[1] == i) {
                boC069[i] = true;
                if (i > 0)
                    bC0B2++;
            }
            if (n == 0 || n == 0x80) {
                if (tx2[k].extra == 0) {
                    if (tx2[k].exprAttr == bC045[i] || (tx2[k].exprAttr == BYTE_A && bC045[i] == 6))
                        if (tx2[k].cnt > 1 || boC069[i] || (curExprLoc[0] != k && k != curExprLoc[1]))
                            boC072[i] = true;
                }
            }
        } else
            boC060[i] = boC057[i];
    }

    for (i = 0; i <= 3; i++) {
        if (boC072[i]) {
            boC07B[i] = true;
            m         = boC069[i];
            j         = 3;
            while (j > i) {
                if (boC072[j]) {
                    if (bC04E[j] == bC04E[i]) {
                        boC072[j] = false;
                        if (i != 0) {
                            boC072[i] = false;
                            m |= boC069[j];
                        }
                    }
                }
                j--;
            }
            if (i != 0 && !m)
                bC0B1++;
        }
    }
}

void Sub_5B96(byte src, byte dst) {
    bC04E[dst]  = bC04E[src];
    bC045[dst]  = bC045[src];
    wC084[dst]  = wC084[src];
    bC0A8[dst]  = bC0A8[src];
    wC096[dst]  = wC096[src];
    boC057[dst] = boC057[src];
}

void Sub_5C1D(byte irReg) {
    byte i;
    Sub_597E();
    i = bC140[wC1C3] = bC04E[irReg];
    if (boC072[irReg])
        tx2[i].extra = wC1C3;

    if (irReg != 0)
        bC0C3[wC1C3] = (bC045[irReg] << 4) | (bC0A8[irReg] & 0xf);
    else
        bC0C3[wC1C3] = 0xB0;
}

void Sub_5C97(byte arg1b) {
    byte i;

    i = bC04E[arg1b] = bC140[wC1C3];
    if (wC1C3 == tx2[i].extra)
        tx2[i].extra = 0;

    boC057[arg1b] = 0;
    bC045[arg1b]  = bC0C3[wC1C3] >> 4;
    bC0A8[arg1b]  = bC0C3[wC1C3] & 0xf;
    if (bC0A8[arg1b] > 7)
        bC0A8[arg1b] = bC0A8[arg1b] | 0xf0;
}

void Sub_5D27(byte irReg) {
    if (stackUsage < ++wC1C3 * 2)
        stackUsage = wC1C3 * 2;
    Sub_5C1D(irReg);
    iCodeArgs[0] = irReg;
    iCodeArgs[1] = LOC_STACK;
    iCodeArgs[2] = wC1C3;
    EncodeFragData(CF_PUSH);
    codeSize++;
}

static void Sub_5E16(byte arg1b) // modified as passed in arg for nested proc
{
    for (byte i = 0; i <= 3; i++)
        if (boC072[i] && !boC069[i])
            Sub_5D27(i);

    if (exprLoc[0] == arg1b)
        exprLoc[0] = 9;
    else
        exprLoc[1] = 9;
} /* Sub_5E16() */

void Sub_5D6B(byte arg1b) {

    if (boC072[arg1b]) {
        if (boC069[arg1b])
            Sub_5E16(arg1b); // modified to pass as arg for nested proc
        Sub_5D27(arg1b);
    } else if (boC069[arg1b]) {
        for (byte i = 0; i <= 3; i++) {
            if (bC04E[i] == bC04E[arg1b] && i != arg1b && bC045[i] == bC045[arg1b]) {
                if (exprLoc[0] == arg1b)
                    exprLoc[0] = i;
                else
                    exprLoc[1] = i;
                return;
            }
        }
        Sub_5E16(arg1b);
        Sub_5D27(arg1b);
    }
}

void Sub_5E66(byte arg1b) {
    byte j   = curExprLoc[0];
    byte k   = curExprLoc[1];
    curExprLoc[0] = 0;
    curExprLoc[1] = 0;
    arg1b    = (arg1b >> 3) | (arg1b << 5);
    Sub_597E();
    for (byte i = 0; i <= 3; i++) {
        if (arg1b & 1) {
            if (boC072[i])
                Sub_5D27(i);
            boC057[i] = 0;
            bC04E[i]  = 0;
            Sub_597E();
        }
        arg1b = (arg1b << 1) | (arg1b >> 7);
    }
    curExprLoc[0] = j;
    curExprLoc[1] = k;
}

void Sub_5EE8() {
    Sub_5795(wC1C7);
    info = blk[blkId].info;
    if (info && (info->flag & F_INTERRUPT)) {
        for (int i = IR_PSW; i <= IR_H; i++) {
            iCodeArgs[0] = i; /*  pop psw, pop b, pop d, pop h */
            iCodeArgs[1] = LOC_REG;
            EncodeFragData(CF_POP);
        }
        EncodeFragData(CF_EI);
        codeSize += 5;
    }
}

void Sub_5F4B(word val, info_t *pInfo, byte exprAttr, byte exprLoc) {
    tx2[tx2qp].right    = val;
    tx2[tx2qp].left     = ToIdx(pInfo);
    tx2[tx2qp].exprAttr     = exprAttr;
    tx2[tx2qp].exprLoc     = exprLoc;
    tx2[tx2qp].nodeType = exprLoc == LOC_REG ? T2_NUMBER : T2_IDENTIFIER;
}

void GetVal(byte slot, wpointer pAcc, wpointer pAccFlag) {
    if (tx2[slot].nodeType == T2_IDENTIFIER || tx2[slot].nodeType == T2_NUMBER) {
        *pAcc = tx2[slot].right;
        info  = FromIdx(tx2[slot].left);
        if (!info || (info->flag & (F_MEMBER | F_BASED | F_ABSOLUTE)))
            *pAccFlag = 0;
        else if ((info->flag & F_AUTOMATIC))
            *pAccFlag = 0x100;
        else if ((info->flag & F_EXTERNAL))
            *pAccFlag = 0x400 | info->extId;
        else if ((info->flag & F_MEMORY))
            *pAccFlag = 0x800;
        else if (info->type == PROC_T)
            *pAccFlag = 0x1000 | info->procId;
        else if ((info->flag & F_DATA))
            *pAccFlag = 0x200;
        else
            *pAccFlag = 0x2000;
    } else {
        *pAcc     = 0;
        *pAccFlag = slot ? 0x4000 : 0;
    }
}

void Sub_611A() {
    for (byte i = 0; i <= 1; i++) {
        byte j = curExprLoc[i];
        if (j && --tx2[j].cnt == 0) {
            for (byte k = 0; k <= 3; k++) {
                if (bC04E[k] == j)
                    bC04E[k] = 0;
            }
            bC140[tx2[j].extra] = 0;
        }
    }
}

void Sub_61A9(byte arg1b) {
    bC0C1[arg1b] = b52DD[exprAttr[arg1b]][exprLoc[arg1b]];
}

void Sub_61E0(byte arg1b) {
    if ((nodeControlMap[tx2[arg1b].nodeType] & 0xc0) == 0) {
        iCodeArgs[bC1DB++] = 0xa;
        iCodeArgs[bC1DB++] = tx2[arg1b].extra;
        iCodeArgs[bC1DB++] = (wC1C3 - tx2[arg1b].extra) * 2;
    } else if (tx2[arg1b].left) {
        info           = FromIdx(tx2[arg1b].left);
        iCodeArgs[bC1DB++] = info->flag & F_AUTOMATIC ? 0xc : 0xb;
        iCodeArgs[bC1DB++] = tx2[arg1b].right - info->linkVal;
        iCodeArgs[bC1DB++] = ToIdx(info);
        if ((info->flag & F_AUTOMATIC))
            iCodeArgs[bC1DB++] = tx2[arg1b].right + wC1C3 * 2;
    } else {
        iCodeArgs[bC1DB++] = tx2[arg1b].right < 0x100 ? 8 : 9;
        iCodeArgs[bC1DB++] = tx2[arg1b].right;
    }
}

void Sub_636A(byte arg1b) {
    if (exprLoc[arg1b] <= 3)
        iCodeArgs[bC1DB++] = exprLoc[arg1b];
    else
        Sub_61E0(curExprLoc[arg1b]);
}

void Sub_63AC(byte irReg) {
    if (irReg > IR_H)
        return;
    if (bC045[irReg] <= 6) {
        while (bC0A8[irReg] != 0) {
            if (bC0A8[iCodeArgs[0] = irReg] > 0x7f) {
                bC0A8[irReg]++;
                EncodeFragData(CF_INX);
            } else {
                bC0A8[irReg]--;
                EncodeFragData(CF_DCX);
            }
            codeSize++;
        }
    }
}

void Sub_6416(byte irReg) {
    iCodeArgs[0] = irReg;
    iCodeArgs[1] = LOC_STACK;
    iCodeArgs[2] = wC1C3;
    EncodeFragData(CF_POP);
    codeSize++;
    Sub_5C97(irReg);
    wC1C3--;
}

void GetTx2Item() {
    tx2[tx2qp].nodeType = Rd2Byte();

    switch (3 & nodeControlMap[tx2[tx2qp].nodeType]) {
    case 0:
        if (tx2[tx2qp].nodeType == T2_EOF)
            eofSeen = true;
        break;
    case 1:
        tx2[tx2qp].left = Rd2Word();
        break;
    case 2:
        tx2[tx2qp].left  = Rd2Word();
        tx2[tx2qp].right = Rd2Word();
        break;
    case 3:
        tx2[tx2qp].left  = Rd2Word();
        tx2[tx2qp].right = Rd2Word();
        tx2[tx2qp].extra = Rd2Word();
        break;
    }
}

void chkMerge() {
    /* T2_MODULE not needed if previous was public level label */
    if (curNodeType == T2_MODULE) {
        if (tx2[tx2qp - 1].nodeType == T2_LABELDEF &&
            !(FromIdx(tx2[tx2qp - 1].left)->flag & (F_MODGOTO | F_PUBLIC)))
            tx2qp--; // ignore this item
    } else
        // merge consecutive T2_LINEINFO which have no statements
        if (curNodeType == T2_LINEINFO && tx2[tx2qp].right == 0 &&
            tx2[tx2qp - 1].nodeType == T2_LINEINFO && tx2[tx2qp - 1].right == 0) {
            tx2[tx2qp - 1].extra = tx2[tx2qp].left; // set first blkCnt to new lineCnt
            tx2qp--;                                // and ignore this item
        }
}

void FillTx2Q() {

    tx2qp = 4; // leave fixed at bottom
    // remove any used items from the queue, moving down the others
    if (tx2qEnd > tx2qNxt) {
        byte k = tx2qEnd - tx2qNxt;
        memmove(&tx2[tx2qp], &tx2[tx2qNxt], k * sizeof(tx2_t));
        tx2qp += k;
        // tx2qNxt += k; // removed as updated before used
    }
    bool exceeded = false;
    bool endblk   = false;
    while (tx2qp < 255 && !eofSeen) {
        GetTx2Item();
        curNodeType = tx2[tx2qp].nodeType;
        chkMerge();
        if (tx2qp == 4) { //  first node of statement
            if (curNodeType == T2_STMTCNT || curNodeType == T2_LOCALLABEL || curNodeType == T2_EOF)
                tx2qp++;
            else if ((nodeControlMap[curNodeType] & 0x20)) // meta node so emit
                EmitTopItem();
            else if (!exceeded) {
                exceeded = true;
                Tx2SyntaxError(ERR200); /*  LIMIT EXCEEDED: STATEMENT SIZE */
                EmitTopItem();
            }
        } else
            tx2qp++;
        // T2_BEGMOVE, T2_CALL, T2_CALLVAR, T2_PROCEDURE, T2_GOTO, T2_JMP, T2_JNC, T2_JNZ, T2_ENDPROC
        if (nodeControlMap[curNodeType] & 8)
            endblk = true;
        if (endblk &&
            (curNodeType == T2_STMTCNT || curNodeType == T2_EOF || curNodeType == T2_LOCALLABEL))
            break;
    }
    tx2qEnd = tx2qp; // new end of queue
}

static void SkipStmt(byte startIdx, int8_t direction) {
    tx2qNxt = startIdx + direction;
    while (tx2[tx2qNxt].nodeType != T2_STMTCNT && tx2[tx2qNxt].nodeType != T2_EOF &&
           tx2[tx2qNxt].nodeType != T2_LOCALLABEL)
        tx2qNxt += direction;
}

void setEndFirstStmt() {
    SkipStmt(tx2qEnd, -1);      // find the start of the last stmt in the queue (may be partial)
    if (tx2qNxt == 4 && !eofSeen)   // start seen so assume its after tx2qEnd 
        tx2qNxt = tx2qEnd;
    else {
        //
        for (byte i = tx2qp = 4; tx2qp < tx2qNxt; tx2qp++) {
            nodeControlFlags = nodeControlMap[tx2[tx2qp].nodeType];
            if ((nodeControlFlags & 0x10)) {    // label or halt
                // PROCEDURE LOCALLABEL CASELABEL LABELDEF HALT EOF ENDPROC
                if (i < tx2qp) {    // we have items that generate code
                    if (tx2[tx2qp].nodeType == T2_LOCALLABEL)
                        tx2qNxt = tx2qp;
                    else
                        SkipStmt(tx2qp, -1);    // backup
                    return;
                }
                i++;
            }
            if ((nodeControlFlags & 8)) {   // Basic block end
                // JMPFALSE RETURNBYTE RETURNWORD RETURN BEGMOVE CALL CALLVAR PROCEDURE GOTO JMP JNC JNZ ENDPROC
                SkipStmt(tx2qp, 1); // skip to next statement
                return;
            }
            if ((nodeControlFlags & 0x20))  // none code item
                // STMTCNT LINEINFO MODULE SYNTAXERROR TOKENERROR EOF LIST NOLIST CODE NOCODE EJECT INCLUDE ERROR
                i++;
        }
    }
}
